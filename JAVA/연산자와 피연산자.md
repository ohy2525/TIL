# 연산자와 피연산자

연산자 : 연산을 수행하는 기호

피연산자 : 연산자의 연산 수행 대상

```java
x + 3
        
+ : 연산자
x, 3 : 피연산자
```
모든 연산자는 연산결과를 반환한다.

### 연산자의 종류
![img.png](../연산자%20종류/img.png)

### 연산자의 우선순위와 결합규칙
![img.png](../우선순위와%20결합규칙/img.png)
1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

### 증감 연산자
- 증감 연산자(++) : 피연산자의 값을 1 증가시킨다.
- 감소 연산자(--) : 피연산자의 값을 1 감소시킨다.

|타입|설명|사용 예|
|----|----|----|
|전위형|값이 참조되기 전에 증가시킨다.|j = ++i;|
|후위형|값이 참조된 후에 증가시킨다.|j = i++|
증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다.
- ++i;
- i++;
- 차이 없음

### 형변환 연산자
형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것.
```java
double d = 85.4;
int score = (int)d;
```

### 자동 형변환
```java
float f = 1234;       // int타입의 값을 float타입의 변수에 저장
float f = (float)1234;  

int i = 3.14f;        // 에러
int i = (int)3.14f;   // 수동 형변환
```
형변환을 하는 이유는 주로 서로 다른 두 타입을 일치시키기 위해서인데, 형변환을 생략하면 컴파일러가 알아서 자동적으로 형변환을 한다.

-> 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다.

그래서 표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.
```java
byte b = 100;        // OK. byte타입의 범위(-128 ~ 127)의 값의 대입 (리터럴이기 때문에 컴파일러가 정확한 값 알 수 있음)
byte b = (byte)100;

int i = 100;
byte b = i;          // 에러. int 타입을 byte의 타입에 대입 (컴파일러는 변수가 뭔지 모름)
byte b = (byte)i;

byte b = 1000;       // 에러. byte타입의 범위(-128 ~ 127)를 벗어난 값의 대입
byte b = (byte)1000; // OK. 그러나 값 손실이 발생해서 변수 b 에는 -
```

### 산술 변환
연산 전에 피연산자의 타입을 일치시키는 것
1. 두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)
- long + int   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &rarr; long + long &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rarr; long
- float + int  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &rarr; float + float &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rarr; float
- double + float &rarr; double + double &rarr; double
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
- byte + short &rarr; int + int &rarr; int
- char + short &rarr; int + int &rarr; int

### 조건 연산자
조건식의 결과에 따라 연산결과를 달리한다.
- 조건식 ? 식1(참) : 식2(거짓)
```java
result = (x > y) ? x : y;   //괄호 생략 가능
```